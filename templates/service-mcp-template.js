#!/usr/bin/env node
/**
 * MCP Server for {{SERVICE_NAME}}
 *
 * Auto-generated by: jfl service-agent init
 *
 * This MCP server enables AI agents to interact with this service.
 * It provides tools for querying, controlling, and monitoring the service.
 *
 * Customize the tools below to expose service-specific functionality.
 */

// ============================================================================
// Configuration
// ============================================================================

const SERVICE_NAME = "{{SERVICE_NAME}}"
const SERVICE_DESCRIPTION = "{{SERVICE_DESCRIPTION}}"
const SERVICE_VERSION = "{{SERVICE_VERSION}}"
const SERVICE_PATH = __dirname

// Service Manager URL for inter-service communication
const SERVICE_MANAGER_URL = process.env.SERVICE_MANAGER_URL || "http://localhost:3402"

// ============================================================================
// Service Mesh Client (for calling other services)
// ============================================================================

class ServiceMeshClient {
  constructor(serviceManagerUrl = SERVICE_MANAGER_URL) {
    this.serviceManagerUrl = serviceManagerUrl
  }

  async callService(serviceName, toolName, args = {}) {
    try {
      const response = await fetch(
        `${this.serviceManagerUrl}/registry/${serviceName}/call`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tool: toolName, args }),
        }
      )

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }

      return await response.json()
    } catch (error) {
      throw new Error(`Failed to call ${serviceName}.${toolName}: ${error.message}`)
    }
  }

  async listServices() {
    const response = await fetch(`${this.serviceManagerUrl}/registry`)
    const data = await response.json()
    return data.services || []
  }

  async getServiceInfo(serviceName) {
    const response = await fetch(`${this.serviceManagerUrl}/registry/${serviceName}`)
    return await response.json()
  }
}

const meshClient = new ServiceMeshClient()

// ============================================================================
// Tool Definitions
// ============================================================================

const TOOLS = [
  {
    name: "status",
    description: `Get status of ${SERVICE_NAME}`,
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "health",
    description: `Check health of ${SERVICE_NAME}`,
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "logs",
    description: `Get logs from ${SERVICE_NAME}`,
    inputSchema: {
      type: "object",
      properties: {
        lines: {
          type: "number",
          description: "Number of log lines (default: 50)",
        },
      },
    },
  },
  // ADD CUSTOM TOOLS HERE
  // Example:
  // {
  //   name: "deploy",
  //   description: "Deploy to production",
  //   inputSchema: {
  //     type: "object",
  //     properties: {
  //       environment: { type: "string", enum: ["staging", "production"] }
  //     }
  //   }
  // }
]

// ============================================================================
// Tool Handlers
// ============================================================================

async function handleToolCall(toolName, args) {
  switch (toolName) {
    case "status":
      return await handleStatus()

    case "health":
      return await handleHealth()

    case "logs":
      return await handleLogs(args.lines || 50)

    // ADD CUSTOM TOOL HANDLERS HERE
    // case "deploy":
    //   return await handleDeploy(args)

    default:
      throw new Error(`Unknown tool: ${toolName}`)
  }
}

// ============================================================================
// Standard Tool Implementations
// ============================================================================

async function handleStatus() {
  // Call Service Manager to get status
  try {
    const response = await fetch(`${SERVICE_MANAGER_URL}/services`)
    const data = await response.json()
    const service = data.services.find((s) => s.name === SERVICE_NAME)

    if (!service) {
      return `Service ${SERVICE_NAME} not found in registry`
    }

    return formatServiceStatus(service)
  } catch (error) {
    return `Failed to get status: ${error.message}`
  }
}

async function handleHealth() {
  // Implement health check logic
  // This could check:
  // - Database connection
  // - External API availability
  // - Queue status
  // - Disk space, memory, etc.

  return `${SERVICE_NAME} is healthy`
}

async function handleLogs(lines) {
  try {
    const response = await fetch(
      `${SERVICE_MANAGER_URL}/services/${SERVICE_NAME}/logs?lines=${lines}`
    )
    const data = await response.json()
    return data.logs || "No logs available"
  } catch (error) {
    return `Failed to get logs: ${error.message}`
  }
}

// ============================================================================
// Helpers
// ============================================================================

function formatServiceStatus(status) {
  const lines = [
    `Service: ${status.name}`,
    `Status: ${status.status}`,
    `Description: ${status.description}`,
  ]

  if (status.port) lines.push(`Port: ${status.port}`)
  if (status.pid) lines.push(`PID: ${status.pid}`)
  if (status.uptime) lines.push(`Uptime: ${status.uptime}`)
  if (status.health_url) lines.push(`Health URL: ${status.health_url}`)

  return lines.join("\n")
}

// ============================================================================
// Example: Calling Another Service
// ============================================================================

// Uncomment to enable inter-service calls:
//
// async function handleDeploy(args) {
//   // Call the CI/CD service to trigger deployment
//   const result = await meshClient.callService('cicd-service', 'trigger_deploy', {
//     service: SERVICE_NAME,
//     environment: args.environment
//   })
//
//   return `Deployment triggered: ${result.deploymentId}`
// }

// ============================================================================
// MCP Protocol Handler
// ============================================================================

const readline = require("readline")

async function handleRequest(request) {
  try {
    switch (request.method) {
      case "initialize":
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: {
            protocolVersion: "2024-11-05",
            capabilities: { tools: {} },
            serverInfo: {
              name: `${SERVICE_NAME}-mcp`,
              version: SERVICE_VERSION,
            },
          },
        }

      case "tools/list":
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: { tools: TOOLS },
        }

      case "tools/call": {
        const { name: toolName, arguments: args } = request.params
        const result = await handleToolCall(toolName, args)

        return {
          jsonrpc: "2.0",
          id: request.id,
          result: {
            content: [
              {
                type: "text",
                text: typeof result === "string" ? result : JSON.stringify(result, null, 2),
              },
            ],
          },
        }
      }

      default:
        return {
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: -32601,
            message: `Method not found: ${request.method}`,
          },
        }
    }
  } catch (error) {
    return {
      jsonrpc: "2.0",
      id: request.id,
      error: {
        code: -32603,
        message: error.message,
      },
    }
  }
}

// ============================================================================
// Main
// ============================================================================

function main() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false,
  })

  rl.on("line", async (line) => {
    try {
      const request = JSON.parse(line)
      const response = await handleRequest(request)
      console.log(JSON.stringify(response))
    } catch (error) {
      console.log(
        JSON.stringify({
          jsonrpc: "2.0",
          id: null,
          error: {
            code: -32700,
            message: "Parse error",
          },
        })
      )
    }
  })

  rl.on("close", () => {
    process.exit(0)
  })
}

main()
