/**
 * Service Agent Management
 *
 * CLI command to generate, manage, and register service MCP servers.
 * Creates executable MCP server binaries for each service in services.json.
 *
 * @purpose Service agent lifecycle management for AI-service communication
 */

import chalk from "chalk"
import ora from "ora"
import * as fs from "fs"
import * as path from "path"
import { homedir } from "os"
import { execSync } from "child_process"
import { fileURLToPath } from "url"
import { dirname } from "path"
import { getMCPConfigFile, findProjectRoot } from "../utils/jfl-config.js"

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const GLOBAL_SERVICES_FILE = path.join(homedir(), ".jfl", "services.json")
const SERVICE_AGENTS_DIR = path.join(homedir(), ".jfl", "service-agents")

// ============================================================================
// Types
// ============================================================================

interface ServiceConfig {
  type: string
  description: string
  port?: number
  start_command: string
  stop_command: string
  detection_command: string
  pid_file?: string
  log_file?: string
  health_url?: string
  mcp?: {
    enabled: boolean
    tools?: any[]
  }
}

interface ServicesConfig {
  version: string
  services: Record<string, ServiceConfig>
}

interface MCPServerConfig {
  command: string
  args: string[]
  env?: Record<string, string>
}

interface MCPConfig {
  mcpServers: Record<string, MCPServerConfig>
}

// ============================================================================
// Service Loading
// ============================================================================

function loadServicesConfig(): ServicesConfig {
  if (!fs.existsSync(GLOBAL_SERVICES_FILE)) {
    throw new Error(`Services file not found: ${GLOBAL_SERVICES_FILE}`)
  }

  const content = fs.readFileSync(GLOBAL_SERVICES_FILE, "utf-8")
  return JSON.parse(content)
}

// ============================================================================
// MCP Server Generation
// ============================================================================

function generateMCPServerBinary(serviceName: string): string {
  const serverPath = path.join(SERVICE_AGENTS_DIR, `${serviceName}-mcp.js`)

  // Find the compiled service-mcp-server.js
  const cliRoot = path.join(__dirname, "..", "..")
  const mcpServerScript = path.join(cliRoot, "dist", "mcp", "service-mcp-server.js")

  if (!fs.existsSync(mcpServerScript)) {
    throw new Error(
      `MCP server script not found: ${mcpServerScript}\n` +
      `Run 'npm run build' to compile the project first.`
    )
  }

  const binaryContent = `#!/usr/bin/env node
/**
 * MCP Server for ${serviceName}
 *
 * Auto-generated by jfl service-agent generate
 * Do not edit manually - regenerate with 'jfl service-agent generate ${serviceName}'
 */

const { spawn } = require('child_process');
const path = require('path');

const mcpServer = path.join(__dirname, '..', '..', '${path.relative(SERVICE_AGENTS_DIR, mcpServerScript)}');
const serviceName = '${serviceName}';

// Spawn the MCP server with the service name
const child = spawn(process.execPath, [mcpServer, serviceName], {
  stdio: 'inherit',
  env: {
    ...process.env,
    DEBUG: process.env.DEBUG || undefined,
  }
});

child.on('exit', (code) => {
  process.exit(code || 0);
});
`

  // Ensure service-agents directory exists
  if (!fs.existsSync(SERVICE_AGENTS_DIR)) {
    fs.mkdirSync(SERVICE_AGENTS_DIR, { recursive: true })
  }

  // Write the binary
  fs.writeFileSync(serverPath, binaryContent, { mode: 0o755 })

  // Make it executable
  try {
    execSync(`chmod +x "${serverPath}"`)
  } catch {
    // chmod might fail on some systems, but mode: 0o755 should handle it
  }

  return serverPath
}

// ============================================================================
// MCP Registration
// ============================================================================

function loadMCPConfig(): MCPConfig {
  const mcpConfigFile = getMCPConfigFile()

  if (!fs.existsSync(mcpConfigFile)) {
    return { mcpServers: {} }
  }

  try {
    const content = fs.readFileSync(mcpConfigFile, "utf-8")
    return JSON.parse(content)
  } catch (error) {
    console.warn(chalk.yellow(`Failed to parse ${mcpConfigFile}, starting fresh`))
    return { mcpServers: {} }
  }
}

function saveMCPConfig(config: MCPConfig): void {
  const mcpConfigFile = getMCPConfigFile()

  // Ensure parent directory exists
  const mcpDir = path.dirname(mcpConfigFile)
  if (!fs.existsSync(mcpDir)) {
    fs.mkdirSync(mcpDir, { recursive: true })
  }

  fs.writeFileSync(mcpConfigFile, JSON.stringify(config, null, 2) + "\n")
}

function registerServiceAgent(serviceName: string, serverPath: string): void {
  const config = loadMCPConfig()

  // Add or update the service MCP server
  config.mcpServers[serviceName] = {
    command: "node",
    args: [serverPath],
  }

  saveMCPConfig(config)
}

function unregisterServiceAgent(serviceName: string): void {
  const config = loadMCPConfig()

  if (config.mcpServers[serviceName]) {
    delete config.mcpServers[serviceName]
    saveMCPConfig(config)
  }
}

// ============================================================================
// Commands
// ============================================================================

export async function generate(serviceName: string): Promise<void> {
  const spinner = ora(`Generating MCP server for ${serviceName}...`).start()

  try {
    const servicesConfig = loadServicesConfig()
    const serviceConfig = servicesConfig.services[serviceName]

    if (!serviceConfig) {
      spinner.fail(`Service "${serviceName}" not found in configuration`)
      console.log(chalk.dim(`Available services: ${Object.keys(servicesConfig.services).join(", ")}`))
      process.exit(1)
    }

    // Check if MCP is enabled
    if (serviceConfig.mcp && serviceConfig.mcp.enabled === false) {
      spinner.warn(`MCP is disabled for service "${serviceName}"`)
      console.log(chalk.dim(`To enable, set mcp.enabled: true in ${GLOBAL_SERVICES_FILE}`))
      process.exit(0)
    }

    const serverPath = generateMCPServerBinary(serviceName)
    spinner.succeed(`Generated MCP server: ${serverPath}`)

    // Show what tools will be available
    console.log(chalk.dim("\nStandard tools:"))
    console.log(chalk.dim(`  - ${serviceName}_status`))
    console.log(chalk.dim(`  - ${serviceName}_start`))
    console.log(chalk.dim(`  - ${serviceName}_stop`))
    console.log(chalk.dim(`  - ${serviceName}_restart`))
    console.log(chalk.dim(`  - ${serviceName}_logs`))
    console.log(chalk.dim(`  - ${serviceName}_health`))

    if (serviceConfig.mcp?.tools && serviceConfig.mcp.tools.length > 0) {
      console.log(chalk.dim("\nCustom tools:"))
      serviceConfig.mcp.tools.forEach((tool: any) => {
        console.log(chalk.dim(`  - ${serviceName}_${tool.name}`))
      })
    }

    console.log(chalk.dim(`\nNext: Run 'jfl service-agent register' to add to Claude Code`))
  } catch (error) {
    spinner.fail("Failed to generate MCP server")
    console.error(chalk.red(error instanceof Error ? error.message : String(error)))
    process.exit(1)
  }
}

export async function generateAll(): Promise<void> {
  const spinner = ora("Generating MCP servers for all services...").start()

  try {
    const servicesConfig = loadServicesConfig()
    const services = Object.keys(servicesConfig.services)

    if (services.length === 0) {
      spinner.info("No services found in configuration")
      process.exit(0)
    }

    spinner.stop()

    for (const serviceName of services) {
      await generate(serviceName)
    }

    console.log(chalk.green(`\n✓ Generated ${services.length} service agents`))
  } catch (error) {
    spinner.fail("Failed to generate service agents")
    console.error(chalk.red(error instanceof Error ? error.message : String(error)))
    process.exit(1)
  }
}

export async function register(serviceName?: string): Promise<void> {
  const spinner = ora("Registering service agents with Claude Code...").start()

  try {
    const servicesConfig = loadServicesConfig()
    const servicesToRegister = serviceName
      ? [serviceName]
      : Object.keys(servicesConfig.services)

    let registered = 0

    for (const name of servicesToRegister) {
      const serverPath = path.join(SERVICE_AGENTS_DIR, `${name}-mcp.js`)

      if (!fs.existsSync(serverPath)) {
        spinner.warn(`MCP server not found for "${name}", generating...`)
        await generate(name)
      }

      registerServiceAgent(name, serverPath)
      registered++
    }

    const mcpConfigFile = getMCPConfigFile()
    const projectRoot = findProjectRoot()

    spinner.succeed(`Registered ${registered} service agent(s) in ${mcpConfigFile}`)

    if (projectRoot) {
      console.log(chalk.green(`\n✓ MCP config written to project: ${path.relative(process.cwd(), mcpConfigFile)}`))
      console.log(chalk.dim("Claude Code will automatically detect this project-local config"))
    } else {
      console.log(chalk.yellow(`\n⚠️  MCP config written to: ${mcpConfigFile}`))
      console.log(chalk.dim("This is in JFL's namespace. To use in a project:\n"))
      console.log(chalk.cyan(`  ln -s ${mcpConfigFile} <project>/.mcp.json\n`))
    }

    console.log(chalk.dim("Restart Claude Code to activate the new MCP servers"))
  } catch (error) {
    spinner.fail("Failed to register service agents")
    console.error(chalk.red(error instanceof Error ? error.message : String(error)))
    process.exit(1)
  }
}

export async function unregister(serviceName: string): Promise<void> {
  const spinner = ora(`Unregistering ${serviceName}...`).start()

  try {
    const mcpConfigFile = getMCPConfigFile()
    unregisterServiceAgent(serviceName)
    spinner.succeed(`Unregistered ${serviceName} from ${mcpConfigFile}`)
  } catch (error) {
    spinner.fail("Failed to unregister service agent")
    console.error(chalk.red(error instanceof Error ? error.message : String(error)))
    process.exit(1)
  }
}

export async function list(): Promise<void> {
  try {
    const servicesConfig = loadServicesConfig()
    const mcpConfig = loadMCPConfig()

    console.log(chalk.bold("\nService Agents:"))
    console.log()

    for (const [name, config] of Object.entries(servicesConfig.services)) {
      const serverPath = path.join(SERVICE_AGENTS_DIR, `${name}-mcp.js`)
      const exists = fs.existsSync(serverPath)
      const registered = !!mcpConfig.mcpServers[name]

      const status = exists && registered
        ? chalk.green("✓ active")
        : exists
        ? chalk.yellow("⚠ generated (not registered)")
        : chalk.dim("○ not generated")

      console.log(`  ${status} ${chalk.bold(name)}`)
      console.log(`    ${chalk.dim(config.description)}`)

      if (config.mcp?.tools && config.mcp.tools.length > 0) {
        console.log(chalk.dim(`    Custom tools: ${config.mcp.tools.map((t: any) => t.name).join(", ")}`))
      }

      console.log()
    }

    console.log(chalk.dim("Commands:"))
    console.log(chalk.dim("  jfl service-agent generate <name>  - Generate MCP server"))
    console.log(chalk.dim("  jfl service-agent register          - Register all agents"))
    console.log(chalk.dim("  jfl service-agent generate-all      - Generate all agents"))
  } catch (error) {
    console.error(chalk.red(error instanceof Error ? error.message : String(error)))
    process.exit(1)
  }
}

export async function clean(): Promise<void> {
  const spinner = ora("Cleaning up service agents...").start()

  try {
    if (fs.existsSync(SERVICE_AGENTS_DIR)) {
      fs.rmSync(SERVICE_AGENTS_DIR, { recursive: true, force: true })
    }

    spinner.succeed("Cleaned up all service agents")
    console.log(chalk.dim("Run 'jfl service-agent generate-all' to regenerate"))
  } catch (error) {
    spinner.fail("Failed to clean up service agents")
    console.error(chalk.red(error instanceof Error ? error.message : String(error)))
    process.exit(1)
  }
}

// ============================================================================
// Service-Local MCP Server Initialization
// ============================================================================

export async function init(servicePath?: string): Promise<void> {
  const targetPath = servicePath ? path.resolve(servicePath) : process.cwd()
  const spinner = ora(`Initializing MCP server in ${targetPath}...`).start()

  try {
    // Check if already initialized
    const mcpServerPath = path.join(targetPath, ".jfl-mcp.js")
    const mcpConfigPath = path.join(targetPath, ".jfl-mcp.config.json")

    if (fs.existsSync(mcpServerPath)) {
      spinner.warn("MCP server already exists")
      console.log(chalk.dim(`Existing: ${mcpServerPath}`))

      const readline = await import("readline")
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })

      const answer = await new Promise<string>((resolve) => {
        rl.question(chalk.yellow("Overwrite? (y/N): "), resolve)
      })
      rl.close()

      if (answer.toLowerCase() !== "y") {
        console.log(chalk.gray("Cancelled"))
        process.exit(0)
      }
    }

    // Read package.json to get service name and description
    const packageJsonPath = path.join(targetPath, "package.json")
    let serviceName = path.basename(targetPath)
    let serviceDescription = "Service description"
    let serviceVersion = "1.0.0"

    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"))
      serviceName = packageJson.name || serviceName
      serviceDescription = packageJson.description || serviceDescription
      serviceVersion = packageJson.version || serviceVersion
    }

    // Load template
    const templatePath = path.join(__dirname, "../../templates/service-mcp-template.js")
    let template = fs.readFileSync(templatePath, "utf-8")

    // Substitute variables
    template = template.replace(/{{SERVICE_NAME}}/g, serviceName)
    template = template.replace(/{{SERVICE_DESCRIPTION}}/g, serviceDescription)
    template = template.replace(/{{SERVICE_VERSION}}/g, serviceVersion)

    // Write MCP server
    fs.writeFileSync(mcpServerPath, template, { mode: 0o755 })

    // Make executable
    try {
      execSync(`chmod +x "${mcpServerPath}"`)
    } catch {
      // chmod might fail on some systems
    }

    // Create config file
    const config = {
      service: {
        name: serviceName,
        description: serviceDescription,
        version: serviceVersion,
        path: targetPath,
      },
      mcp: {
        enabled: true,
        tools: [],
      },
    }

    fs.writeFileSync(mcpConfigPath, JSON.stringify(config, null, 2))

    spinner.succeed("MCP server initialized")

    console.log()
    console.log(chalk.green("✓ Created files:"))
    console.log(chalk.dim(`  ${mcpServerPath}`))
    console.log(chalk.dim(`  ${mcpConfigPath}`))
    console.log()
    console.log(chalk.bold("Next steps:"))
    console.log(chalk.dim("1. Edit .jfl-mcp.js to add custom tools"))
    console.log(chalk.dim("2. Register service with GTM project:"))
    console.log(chalk.dim(`   jfl onboard ${targetPath}`))
    console.log()
  } catch (error) {
    spinner.fail("Failed to initialize MCP server")
    console.error(chalk.red(error instanceof Error ? error.message : String(error)))
    process.exit(1)
  }
}
